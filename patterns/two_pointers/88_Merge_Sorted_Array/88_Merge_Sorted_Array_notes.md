下面是为你整理的一份**书面化、可复用的刷题笔记**，内容不仅包含本题的最优解与思路，也系统总结了你在本题中的**思路演进**以及**后续刷题时应重点关注的判断原则**。整体风格偏向技术笔记，适合直接放进 Notion / Obsidian / Markdown 文档中。

---

## 题目：Merge Sorted Array（LeetCode 88）

### 一、问题本质

给定两个已经按非递减顺序排列的整数数组 `nums1` 和 `nums2`，其中：

* `nums1` 的长度为 `m + n`
* 前 `m` 个元素为有效数据
* 后 `n` 个元素为占位空间（值为 0，不参与排序）
* `nums2` 的长度为 `n`

要求将 `nums2` 合并进 `nums1`，使最终结果仍然有序，并且**必须原地修改 `nums1`，不能返回新数组**。

---

### 二、最优解法概述

#### 核心思想

利用 `nums1` 尾部的空位，从**后往前**合并两个数组。
通过三个指针分别指向：

* `nums1` 有效部分的末尾
* `nums2` 的末尾
* `nums1` 的最后一个可写位置

每一步选取当前较大的元素写入 `nums1` 的末尾，从而避免覆盖尚未使用的数据。

---

### 三、最优算法（时间 O(m+n)，空间 O(1)）

```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        i = m - 1
        j = n - 1
        pos = m + n - 1

        while i >= 0 and j >= 0:
            if nums1[i] > nums2[j]:
                nums1[pos] = nums1[i]
                i -= 1
            else:
                nums1[pos] = nums2[j]
                j -= 1
            pos -= 1

        while j >= 0:
            nums1[pos] = nums2[j]
            j -= 1
            pos -= 1
```

---

### 四、时间与空间复杂度分析

* 时间复杂度：O(m + n)
  每个元素最多被比较和写入一次，两个指针单向移动，不存在回退或嵌套循环。

* 空间复杂度：O(1)
  所有操作均在 `nums1` 内完成，未使用额外数组。

---

### 五、个人思路演进总结（非常关键）

你在这道题中的思路变化是**非常典型且正确的学习路径**，值得明确记录。

#### 1. 初始直觉

* 使用两个数组的指针
* 从前往后比较并写入 `nums1`

这是合并有序数组最自然的想法，但忽略了一个关键事实：

> 目标数组 `nums1` 本身也是输入数据，前向写入会覆盖尚未使用的元素。

#### 2. 发现问题

* 在写入过程中，`nums1` 的原始数据被提前破坏
* 尝试通过调整 index 或回退指针修复，但在 `for` 循环中不可控

这一阶段你明确意识到：

> 只用 `nums1` 的 index 作为循环变量是不可靠的。

这是从“语法层面”转向“算法控制权”的重要一步。

#### 3. 思路转折点

你提出了一个本质性问题：

> 当 `nums2` 的元素更大时，`nums1` 中还没用到的元素应该怎么办？

这直接引出了关键结论：

> 指针的移动必须是“谁被选中，谁才移动”，而不是依赖固定循环。

这一步意味着你已经从“写代码”转向了“控制状态机”。

---

### 六、从这道题提炼出的通用刷题原则

以下几点对你后续刷 two pointers / in-place 题目非常重要：

#### 1. 何时应考虑“从后往前写”

当同时满足以下条件时，优先考虑反向写入：

* 目标数组本身是输入之一
* 目标数组尾部存在冗余空间
* 要求原地修改，不能使用额外数组

这是一个可迁移的判断模板，而不是本题特例。

---

#### 2. 不要用固定 for 循环驱动双指针合并

在以下场景中，应避免只用一个 index 控制循环：

* 每一步到底消耗哪个数组是动态决定的
* 指针是否移动取决于比较结果

此时应使用 `while`，并显式控制每个指针的移动。

---

#### 3. 双指针的核心不在“两个指针”，而在“状态收敛”

双指针题目的本质是：

* 每一步都缩小问题规模
* 每个指针只能单向移动
* 总移动次数是可预期、可上界的

一旦能证明“每个元素最多被处理一次”，时间复杂度自然是线性的。

---

### 七、可复用的一句话总结

* 技术层面：
  本题通过从后向前的双指针合并，在 O(m+n) 时间和 O(1) 空间内完成原地排序。

* 思维层面：
  当目标数组既是输入又是输出时，应优先考虑如何利用已有空间，避免覆盖尚未使用的数据。

---

如果你愿意，下一步我可以帮你把这道题和以下题目抽象成同一个“模板族”：

* 26 / 27 / 283（前向覆盖型）
* 88 / 977（后向填充型）

这样你之后刷题会非常快。
